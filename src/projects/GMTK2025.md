---
title: GMTK 2025
description: A post about the lessons learned in development of a submission to the game maker's toolkit game jam 2025.
date: 4/5/2025
id: GMTK2025
img: src/title_screen.png
tags: "GameDev, C++, OpenGl"
...

![GMTK game jam image header](https://img.itch.zone/aW1hZ2UyL2phbS8zODU3MjcvMjA3Nzk0MTEucG5n/original/6fSjCW.png)
## Introduction

The game maker's toolkit (GMTK) game jam is the largest game jam in the world, where competitors have four days to build a game based on a theme announced at the start of the Jam. When my friend [Chris](https://github.com/CodingPluto), suggested putting a team together to make s submission to the jam, it sounded like a lot of fun, so a team was put together with two other developers and an artist. We did not end up making a submission to the jam. The other two devs had to pull out before the jam due to other commitments, our artist flaked on us about halfway though the jam, and then all the code broke. Nevertheless there are many takeaways from this experience, as you learn much more in failure then you do in success.

### Language and development tools
The first question asked after the idea was pitched was: What development tools should we use? Several were suggested, from game engines like [Unity](https://unity.com) or [Godot](https://godotengine.org) to langues such as [Rust](https://www.rust-lang.org) before deciding on using C++, OpenGL and a graphics library called [SDL](https://wiki.libsdl.org/SDL3/FrontPage). This was probably our first mistake.

> “C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.”
> 
>    ― Bjarne Stroustrup, the creator of C++

C++ was chosen as me and Chris had both used it before, and were relatively good at it, plus C++, being a relatively low level language meant that it was pretty fast, and we could hook into utilising the graphics card using OpenGL, making the game run very fast. The downside of C++ is we had to write the game entirely from the ground up, which is a tall order in four days.

### Rendering
The game needs a list of game objects to pass to the renderer, so that they may be rendered on screen. To avoid calling the copy constructor, a slow and time consuming process, a list of pointers to different game objects is passed to the renderer instead. Herein lies the issue, if a game object is deleted, and then it is passed to the renderer, it will seg fault as the computer tries to read memory that has been deleted. One possible solution to this is to, when deleting a game object, search through the list of game objects and remove itself from the list, this is an $O(n^2)$ operation as a linear search ($O(n)$) needs to performed for every single deleted object.

I came up with a better solution to this issue of rendering in C++, which ended up being only $O(n)$:
```c++
int queue_size = game_objects_.size();

  while (!render_front_.empty()) {
    GameObject* game_object = render_front_.top();
    render_front_.pop();
    if (game_object) {
      Render(game_object);
      game_objects_.push(game_object);
    }
  }

  for (int i = 0; i < queue_size; ++i) {
    GameObject* game_object = game_objects_.front();
    game_objects_.pop();
    if (game_object) {

      UpdateReturn add = game_object->Update();
      switch (add) {
      case RENDER: {
        Render(game_object);
        game_objects_.push(game_object);
        break;
      }
      case DELETE: {
        delete game_object;
        break;
      }
      case FRONT: {
        render_front_.push(game_object);
        break;
      }
      case BACK: {
        render_back_.push(game_object);
        break;
      }
      default: {
        break;
      }
      }
    }
  }
  while (!render_back_.empty()) {
    GameObject* game_object = render_back_.top();
    render_back_.pop();
    if (game_object) {
      Render(game_object);
      game_objects_.push(game_object);
    }
  }

```
This solution mainly works around a queue, an abstract data type that is FIFO (first in last out). In short all game objects are added to the queue upon start up, the game then makes a note of the length of the queue upon execution of the update function. It then iterates through all items in the queue that were originally there, calling their update functions that can return one of four enumerated values:
1. **RENDER** - The default, it passes the game object to be rendered to the renderer, and then pushes it to the back of the queue. next frame this object will exist in the queue and will be rendered again if RENDER is returned again.
2. **DELETE** - this is where the object is deleted, you will also notice it is not added to the back of the queue, which means that the update function will not be called on the pointer to where the game object was before it was deleted, and thereby not seg faulting.
3. **FRONT**
4. **BACK**

