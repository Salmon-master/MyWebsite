---
title: GMTK 2025
description: A post about the lessons learned in development of a submission to the game maker's toolkit game jam 2025.
date: 4/5/2025
id: GMTK2025
img: src/title_screen.png
tags: "GameDev, C++, OpenGl"
...

![GMTK game jam image header](https://img.itch.zone/aW1hZ2UyL2phbS8zODU3MjcvMjA3Nzk0MTEucG5n/original/6fSjCW.png)
## Introduction

The game maker's toolkit (GMTK) game jam is the largest game jam in the world, where competitors have four days to build a game based on a theme announced at the start of the Jam. When my friend [Chris](https://github.com/CodingPluto), suggested putting a team together to make s submission to the jam, it sounded like a lot of fun, so a team was put together with two other developers and an artist. We did not end up making a submission to the jam. The other two devs had to pull out before the jam due to other commitments, our artist flaked on us about halfway though the jam, and then all the code broke. Nevertheless there are many takeaways from this experience, as you learn much more in failure then you do in success.

### Language and development tools
The first question asked after the idea was pitched was: What development tools should we use? Several were suggested, from game engines like [Unity](https://unity.com) or [Godot](https://godotengine.org) to langues such as [Rust](https://www.rust-lang.org) before deciding on using C++, OpenGL and a graphics library called [SDL](https://wiki.libsdl.org/SDL3/FrontPage). This was probably our first mistake.

> “C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.”
> 
>    ― Bjarne Stroustrup, the creator of C++

C++ was chosen as me and Chris had both used it before, and were relatively good at it, plus C++, being a relatively low level language meant that it was pretty fast, and we could hook into utilising the graphics card using OpenGL, making the game run very fast. The downside of C++ is we had to write the game entirely from the ground up, which is a tall order in four days.

### Idea
We were quite proud of the idea we came up with for the jam. The theme for this years jam was:
> Loop

We came up with the rather meta take on this theme by basing our game around the phrase *"keeping in the loop"*, and we decided to make a spy game.

The basic game loop was to be a true top down pixel art shooter (think [Hotline Miami](https://store.steampowered.com/app/219150/Hotline_Miami) ), where the player was tasked with breaking into a succession of buildings and stealing a documents to help decode an intercepted encrypted message.
![GMTK Gamplay Image](src/gmtk2025-Gameplaypng.png "Some Gameplay") *Some Gameplay*
 
### Rendering
The game needs a list of game objects to pass to the renderer, so that they may be rendered on screen. To avoid calling the copy constructor, a slow and time consuming process, a list of pointers to different game objects is passed to the renderer instead. Herein lies the issue, if a game object is deleted, and then it is passed to the renderer, it will seg fault as the computer tries to read memory that has been deleted. One possible solution to this is to, when deleting a game object, search through the list of game objects and remove itself from the list, this is an $O(n^2)$ operation as a linear search ($O(n)$) needs to performed for every single deleted object.

I came up with a better solution to this issue of rendering in C++, which ended up being only $O(n)$:
```c++
int queue_size = game_objects_.size();

  while (!render_front_.empty()) {
    GameObject* game_object = render_front_.top();
    render_front_.pop();
    if (game_object) {
      Render(game_object);
      game_objects_.push(game_object);
    }
  }

  for (int i = 0; i < queue_size; ++i) {
    GameObject* game_object = game_objects_.front();
    game_objects_.pop();
    if (game_object) {

      UpdateReturn add = game_object->Update();
      switch (add) {
      case RENDER: {
        Render(game_object);
        game_objects_.push(game_object);
        break;
      }
      case DELETE: {
        delete game_object;
        break;
      }
      case FRONT: {
        render_front_.push(game_object);
        break;
      }
      case BACK: {
        render_back_.push(game_object);
        break;
      }
      default: {
        break;
      }
      }
    }
  }
  while (!render_back_.empty()) {
    GameObject* game_object = render_back_.top();
    render_back_.pop();
    if (game_object) {
      Render(game_object);
      game_objects_.push(game_object);
    }
  }

```
This solution mainly works around a queue, an abstract data type that is FIFO (first in last out). In short all game objects are added to the queue upon start up, the game then makes a note of the length of the queue upon execution of the update function. It then iterates through all items in the queue that were originally there, calling their update functions that can return one of four enumerated values:

1. **RENDER** - The default, it passes the game object to be rendered to the renderer, and then pushes it to the back of the queue. next frame this object will exist in the queue and will be rendered again if RENDER is returned again.
2. **DELETE** - this is where the object is deleted, you will also notice it is not added to the back of the queue, which means that the update function will not be called on the pointer to where the game object was before it was deleted, and thereby not seg faulting.
3. **FRONT** -  The object should be sent sent ot the front of the render queue.
4. **BACK** - The object should be sent sent ot the back of the render queue.

Note that I accidentally managed to reverse the direction of these two so that the **BACK** actually fenders the item at the front and the **FRONT** actually renders an item at the back.

The beauty of this solution is that it reduced the coupling of the game class to the game objects, meaning that delete can be returned and it will deled itsle ffrom the main list of objects.

There are a couple of limitations however:
1. 
2. You cannot call `delete` on a game object in code. If you do this, the queue will try and read garbage memory, and the program will seg fault.
3. All game objects must be allocated on the heap to avoid the game object going out of scope and by the same process as above, the program seg faults.

These last two limitations were where a major bug in the development of the jam was hit. Chris, working without a debugger encountered this late one night after I went to bed with the player class having a stack allocated game object attached to it, and when the player was deleted in the proper manner, the stack allocated game object instance went out of scope and the program then tried to read the memory associated with this object and the program crashed. This lost a load of time while Chris tried in vain to debug this code by littering `std::cout` statements throughout the code. Even after I woke up, it took the better part of a day to located this bug even with the vast suite of debuggihn tools availeb to me through visual studio.  
